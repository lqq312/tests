# kafka概述

kafka是一个分布式的基于发布/订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。一般在大数据领域如果使用Spark进行实时处理，一般都会将kafka作为消息队列的工具来使用。

## 消息队列

消息队列的处理模型：

![](/Users/luqq/Documents/02_tec-doc/kafka_doc/pic/1.1.png)

使用消息队列的好处：

1. 解耦，允许独立的扩展或修改两端的处理过程，只要确保它们遵守同样的接口约束即可。
2. 可恢复性，系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。
3. 缓冲，有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致（主要是生产大于消费）的情况。
4. 灵活性&峰值处理能力，在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见，如果为以能处理这类峰值访问为标准来投入资源随时待命一定是巨大的资源浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷请求而完全崩溃。
5. 异步通信，很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它，想向队列中放入多少消息就放入多少，然后在需要的时候再去处理。

## 消息队列的两种模式

### 点对点模式

一对一，消费者主动拉取数据，消息收到后消息清除。

消息生产者生产消息发送到Queue中，然后消息消费者从Queue中取出并且消费消息。消息被消费以后，Queue中不再有存储，所以消息消费者不可能消费到已经被消费的消息。Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。

![](/Users/luqq/Documents/02_tec-doc/kafka_doc/pic/1.2.png)

### 发布/订阅模式

一对多，消费者消费数据之后不会清除消息（但数据仍有保存时限）。

消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费。

![](/Users/luqq/Documents/02_tec-doc/kafka_doc/pic/1.3.png)

在此模式下仍可选择由消费者拉取消息或者由队列向消费者推送消息。kafka所使用的是由消费者拉取的工作模式（在这种模式下需要消费者不停的轮询队列，如果队列为空则会消耗消费者的资源）。

## kafka基础架构

![](/Users/luqq/Documents/02_tec-doc/kafka_doc/pic/1.4.png)

* Producer：消息生产者，向kafka broker发消息的客户端；
* Consumer：消息消费者，向kafka broker取消息的客户端；
* Broker：对应为kafka集群中的节点；
* Topic：将消息进行分类；
* Partition：用于提高Topic的负载均衡能力；
* Leader：仅为当前Partition的Leader而非Broker的Leader，所有消费者只会找Leader分区进行消费；
* Follower：相当于Leader的备份，从而实现数据的冗余，当Leader宕机后将某一个Follower提升为Leader，Follower的数量可以自定义；
* Consumer group：消费者组，将多个消费者用一个组名，则这些消费者就在一个组中，“同一个消费者组中的多个消费者不能消费同一个分区中的消息（消费者组内每个消费者负责消费不同分区的数据）”，消费者组提高了消费能力但不建议消费者组中的消费者多于分区的数量；
* Zookeeper：用于管理kafka集群，保存队列中的消费者消费到的位置信息（在0.9之后消费的位置信息保存到系统的topic中）。