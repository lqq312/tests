# AOF持久化

快照功能并不是非常耐久（durable）：如果 Redis 因为某些原因而造成故障停机，那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。
尽管对于某些程序来说，数据的耐久性并不是最重要的考虑因素，但是对于那些追求完全耐久能力（full durability）的程序来说，快照功能就不太适用了。
可以通过修改配置文件来打开AOF功能：
    
    appendonly yes

设置完成后每当Redis执行一个改变数据集的命令时（比如SET），这个命令就会被追加到AOF文件的末尾。
这样的话，当 Redis 重新启时，程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。

## AOF重写

因为 AOF 的运作方式是不断地将命令追加到文件的末尾，所以随着写入命令的不断增加，AOF 文件的体 积也会变得越来越大。
举个例子，如果你对一个计数器调用了 100 次INCR ，那么仅仅是为了保存这个计数器的当前值，AOF 文 件就需要使用 100 条记录(entry)。
然而在实际上，只使用一条SET 命令已经足以保存计数器的当前值了，其余 99 条记录实际上都是多余的。 为了处理这种情况，Redis 支持一种有趣的特性:可以在不打断服务客户端的情况下，对 AOF 文件进行重
建(rebuild)。
执行BGREWRITEAOF 命令，Redis 将生成一个新的 AOF 文件，这个文件包含重建当前数据集所需的最
少命令。

Redis2.4以后的版本可以自动触发AOF重写。

## AOF耐久时间

可以配置Redis多久才将数据fsync到磁盘一次（有三个选项）：

* 每次有新命令追加到AOF文件时就执行一次fsync，非常慢，也非常安全；
* 每秒执行一次fsync：足够快（和使用RDB持久化差不多），并且在故障时只会丢失一秒钟的数据；
* 从不fsync：将数据交给操作系统来处理，更快也更不安全。

推荐（也是默认）的措施为每秒执行一次fsync，这种fsync策略可以兼顾速度和安全。

## 如果AOF文件错误后的处理方法

服务器可能在程序正在对 AOF 文件进行写入时停机，如果停机造成了 AOF 文件出错(corrupt)，那么 Redis 在重启时会拒绝载入这个 AOF 文件，从而确保数据的一致性不会被破坏。
当发生这种情况时，可以用以下方法来修复出错的 AOF 文件:

* 为现有的AOF文件创建一个备份；
* 使用Redis附带的redis-check-aof程序，对原来的AOF文件进行修复；
    - redis-check-aof --fix
* （可选）使用diff -u对比修复后的AOF文件和原始AOF文件的备份，查看两个文件之间的不同之处；
* 重启Redis服务器，等待服务器载入修复后的AOF文件，并进行数据恢复。

## AOF的运作方式

AOF重写和RDB创建快照一样，都巧妙地利用了写时复制机制。
以下是AOF重写的执行步骤：

1. Redis执行fork()，现在同时拥有父进程和子进程；
2. 子进程开始将新的AOF文件的内容写入到临时文件；
3. 对于所有新的写入命令，父进程地边将它们累积到一个内在缓存中，一边将这些改动追加到现有的AOF文件的末尾，这样即使在重写的中途发生停机，现有的AOF文件也还是安全的；
4. 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新的AOF文件的末尾；
5. 现在Redis原子地用新文件替换旧文件，之后所有命令都会直接追加到新AOF文件的末尾。
